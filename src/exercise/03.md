# useContext: simple Counter

## üìù Your Notes

### React Context

React Context is a mechanism provided by React in order to share state across
components without having to prop drill.

Prop drilling is when you pass data via props down the React component tree
through components that don't need the it, just so a nested component further
down the tree can access that data.

One solution to this issue is React's Context feature.

By creating context use the `React.createContext` hook, you can then wrap any
components that need that context in the created context's `Provider` component.

Ex:

```javascript
export const UserContext = React.useContext()

const UserContextProvider({children}) {
  const [username, setUsername] = React.useState('')

  const value = [username, setUsername]
  return (
    <UserContext.Provider
      value={value}
      children={children}
    />
  )
}

function App() {
  return (
    <UserContextProvider>
      <main>
        <h1>Welcome My App!/h1>
        <Profile />
      </main>
    </UserContextProvider>
  )
}
```

Any components rendered within the `UserContextProvider` can get access to the
state defined in that component and passed through via the
`UserContext.Provider` component's `value` prop.

```javascript
function Profile() {
  return (
    <div className="profile-container">
      <h2>Profile</h2>
      <ProfileBody />
    </div>
  )
}

function ProfileBody() {
  // could also nab the `setUsername` if needed
  const [username] = React.useContext(UserContext)
  return <p>My name is ${userName}</p>
}
```

### Composition instead of React Context

Many believe that React Context is overkill in most scenarios. Instead of using
React Context, try to opt for better composition of components.

Composition of components is achieved by creating Components that make use of
the `children` prop and allow their consumers to determine what gets rendered as
opposed to being a black box that controls all that gets rendered.

Poor composition is something like the `Profile` component I defined above. It
accepted no props, and you have no idea what `Profile` actually renders. It's
like a black box.

This scenario I'm referring to with the `Profile` component above is incredibly
contrived. I could simply defined the `username` state within App and pass it
down as a prop to `Profile`, but for the sake of this example we'll go with it.
It was just an example of the kind of problem React Context can solve. You can
imagine a more complex component tree many layers deep with more than 1
component that requires the user state.

What if instead we defined `Profile` as such:

```javascript
function Profile({children}) {
  return (
    <div className="profile-container">
      <h1>Welcome to my Profile!</h1>
      {children}
    </div>
  )
}
```

Then App could instead pass the children that get rendered in the Profile and
provide the `username` state to the component that needs it `ProfileBody`,
avoiding prop drilling and without having to use React Context.

```javascript
function App() {
  const [username, setUsername] = React.useState('')
  return (
    <main>
      <h1>I love my App! Welcome!</h1>
      <Profile>
        <h3>Here's some more info about me!</h3>
        <ProfileBody username={username} />
      </ProfileBody>
    </main>
  )
}
```

With that, we've eliminated one layer of prop drilling. Now `Profile` doesn't
accept a `username`, it's job is just to render the `children` it's passed.

This makes `Profile` much more customizable because the consumer can decide what
gets rendered in the `Profile`.

## Background

Sharing state between components is a common problem. The best solution for this
is to üìú
[lift your state](https://react.dev/learn/sharing-state-between-components).
This requires üìú [prop drilling](https://kentcdodds.com/blog/prop-drilling)
which is not a problem, but there are some times where prop drilling can cause a
real pain.

To avoid this pain, we can insert some state into a section of our react tree,
and then extract that state anywhere within that react tree without having to
explicitly pass it everywhere. This feature is called `context`. In some ways
it's like global variables, but it doesn't suffer from the same problems (and
maintainability nightmares) of global variables thanks to how the API works to
make the relationships explicit.

Here's how you use context:

```javascript
import * as React from 'react'

const FooContext = React.createContext()

function FooDisplay() {
  const foo = React.useContext(FooContext)
  return <div>Foo is: {foo}</div>
}

ReactDOM.render(
  <FooContext.Provider value="I am foo">
    <FooDisplay />
  </FooContext.Provider>,
  document.getElementById('root'),
)
// renders <div>Foo is: I am foo</div>
```

`<FooDisplay />` could appear anywhere in the render tree, and it will have
access to the `value` which is passed by the `FooContext.Provider` component.

Note that as a first argument to `createContext`, you can provide a default
value which React will use in the event someone calls `useContext` with your
context, when no value has been provided:

```javascript
ReactDOM.render(<FooDisplay />, document.getElementById('root'))
```

Most of the time, I don't recommend using a default value because it's probably
a mistake to try and use context outside a provider, so in our exercise I'll
show you how to avoid that from happening.

ü¶â Keep in mind that while context makes sharing state easy, it's not the only
solution to Prop Drilling pains and it's not necessarily the best solution
either. React's composition model is powerful and can be used to avoid issues
with prop drilling as well. Learn more about this from
[Michael Jackson on X](https://x.com/mjackson/status/1195495535483817984)

## Exercise

Production deploys:

- [Exercise](https://advanced-react-hooks.netlify.com/isolated/exercise/03.js)
- [Final](https://advanced-react-hooks.netlify.com/isolated/final/03.js)

We're putting everything in one file to keep things simple, but I've labeled
things a bit so you know that typically your context provider will be placed in
a different file and expose the provider component itself as well as the custom
hook to access the context value.

We're going to take the Count component that we had before and separate the
button from the count display. We need to access both the `count` state as well
as the `setCount` updater in these different components which live in different
parts of the tree. Normally lifting state up would be the way to solve this
trivial problem, but this is a contrived example so you can focus on learning
how to use context.

Your job is to fill in the `CountProvider` function component so that the app
works and the tests pass.

## Extra Credit

### 1. üíØ create a consumer hook

[Production deploy](https://advanced-react-hooks.netlify.com/isolated/final/03.extra-1.js)

Imagine what would happen if someone tried to consume your context value without
using your context provider. For example, as mentioned above when discussing the
default value:

```javascript
ReactDOM.render(<FooDisplay />, document.getElementById('root'))
```

If you don't provide a default context value, that would render
`<div>Foo is: </div>`. This is because the context value would be `undefined`.
In real-world scenarios, having an unexpected `undefined` value can result in
errors that can be difficult to debug.

In this extra credit, you need to create a custom hook that I can use like this:

```javascript
const [count, setCount] = useCount()
```

And if you change the `App` to this:

```javascript
function App() {
  return (
    <div>
      <CountDisplay />
      <Counter />
    </div>
  )
}
```

It should throw an error indicating that `useCount` may only be used from within
a (child of a) CountProvider.

### 2. üíØ caching in a context provider

[Production deploy](https://advanced-react-hooks.netlify.com/isolated/final/03.extra-2.js)

Let's try the last exercise over again with a bit more of a complex/practical
example. That's right! We're back to the Pokemon info app! This time it has
caching in place which is cool. So if you enter the same pokemon information,
it's cached so it loads instantaneously.

However, we have a requirement that we want to list all the cached pokemon in
another part of the app, so we're going to use context to store the cache. This
way both parts of the app which need access to the pokemon cache will have
access.

Because this is hard to describe in words (and because it's a completely
separate example), there's a starting point for you in
`./src/exercise/03.extra-2.js`.

## ü¶â Other notes

`Context` also has the unique ability to be scoped to a specific section of the
React component tree. A common mistake of context (and generally any
"application" state) is to make it globally available anywhere in your
application when it's actually only needed to be available in a part of the app
(like a single page). Keeping a context value scoped to the area that needs it
most has improved performance and maintainability characteristics.

## ü¶â Feedback

Fill out
[the feedback form](https://ws.kcd.im/?ws=Advanced%20React%20Hooks%20%F0%9F%94%A5&e=03%3A%20useContext%3A%20simple%20Counter&em=).
